-- 用于公司所属人员进行在线申请故障处理 --

业务需求描述：
1，用户登陆后，可以在企微应用中提交申请单，申请单中包含联系电话、故障描述，故障图片等信息
2，申请单生成后会自动分配到一个工程师进行处理，且此时会【提示用户申请单已创建，正由工程师x进行处理；提示工程师，一个申请单已分配给你】
3，接到申请单的工程师对于申请单可以进行【重分配、跟进、完成】
4，工程师进行【完成】操作时，需要对本次故障进行故障分类归属（故障类别数据当前为静态数据，当前不考虑对其进行管理）
5，员工可以看到自己申请的所有申请单，能在申请列表中看到申请单的处理进度，如果申请单是【完成】状态，则可以进行评价打分
6，工程师的自动分配是需要可以设置的（存在一个工程师对应区域的设置管理，当前也是静态数据），
按照申请员工的部门名称进行匹配，如果没有匹配到，则分配给负责总部的工程师，由他进行再次分配给其他工程师
7，工程师可以看到自己正处理的单和已完成的申请单【分配后不可见，且不能分配给自己】
8，管理员可以查看所有的申请单情况，可能后续会对申请单进行总览，对工程师信息进行总览，对故障进行总览（具体的汇总信息未确定）

------------------------------

事件识别：
注：1，事件为已发生的事实，使用xxx已xxx的句式进行描述，且描述尽量不要使用【已创建、已更新】这样的技术类词语，应靠近业务人员使用的场景【上述需求中“工单已创建”应描述为“工单已申请”】
2，对查询类需求不进行识别，试业务和技术专注于关键时间点和事件的识别，减少前期对模型的影响【业务引发的数据的读写是有很多的处理模式的，当前讨论读模型得不偿失】

业务描述拆分事件：
1，用户登陆后，可以在企微应用中提交申请单，申请单中包含联系电话、故障描述，故障图片等信息
>>> 用户已登陆、工单已申请 >>> 业务说：工单这个词语不好，需要改为申请单； 技术说：用户登陆不属于业务场景，我们不需要对它进行判断，业务说，行
==> 最终识别： 申请单已申请

2，申请单生成后会自动分配到一个工程师进行处理，且此时会【提示用户申请单已创建，正由工程师x进行处理；提示工程师，一个申请单已分配给你】
>>> 申请单已分配、工程师已接单、消息已发送 >>> 业务说：工程师已接单，在状态上说就默认他在处理了，所以可以说是【工程师已处理】，技术说：已处理并不是已完成哦，完成状态是工程师自己点击处理完成，业务说：没事就这样
>>> 技术说，消息已发送事件很模糊，它并不是既定的事实，我们可以描述为：信息已发送和信息已接收，业务想了想说，目前消息没有反馈需求，所以不需要“消息已接收”
==> 最终识别： 申请单已分配、工程师已处理、消息已发送

3，接到申请单的工程师对于申请单可以进行【重分配、跟进、完成】
>>> 申请单已分配、申请单已跟进、申请单已完成 >>> 技术说，这里的分配和2中的“申请单已分配”是重复的，这里可以改为：“申请单已重新分配”
==> 最终识别： 申请单已重新分配、申请单已跟进、申请单已完成

4，工程师进行【完成】操作时，需要对本次故障进行故障分类归属（故障类别数据当前为静态数据，当前不考虑对其进行管理）
>>> 故障已分类 >>> 技术说，这里应该描述为申请单已故障分类，业务说，故障分类也是可以理解的，技术说，故障分类词性不清晰，而且可能会和以后的故障相关的需求相互矛盾，这里最好描述清楚，业务说行。
==> 最终识别： 申请单已故障分类

5，用户可以在申请列表中看到当前的处理进度，如果申请单是【完成】状态，则可以进行评价打分
>>> 申请单已查看、用户已评价 >>> 技术说：查看不产生业务影响，我们可以稍后再讨论，它不属于事件；而且“用户已评价”是不是有点界限不清晰，用户可以有很多的申请单，改为“申请单已评价”吧，一个申请单只能有一个评价，业务觉得可以
>> 申请单已评价

6，工程师的自动分配是需要可以设置的（存在一个工程师对应区域的设置管理，当前也是静态数据），按照申请员工的部门名称进行匹配，如果没有匹配到，则分配给负责总部的工程师，由他进行再次分配给其他工程师
>>> 很明显，这点是对业务得补充，“存在一个数据源，保证每次分配必定能有工程师处理申请单”，所以这里暂时没有识别出事件
>>> 这里和业务沟通，得到业务想要表达的东西，达成双方的统一认知，有助于业务统一语言的形成，至于如何实现可以延后讨论(聚合自身的策略/外部服务等)

7，工程师可以看到自己正处理的单和已完成的申请单【分配后不可见，且不能分配给自己】
>>> 无事件

8，管理员可以查看所有的申请单情况，可能后续会对申请单进行总览，对工程师信息进行总览，对故障进行总览
>>> 无事件，且描述的是模糊的“浏览、总览”这样的读模型，此步骤不关注

==>> 使用工具画出这些事件

------------------------------

绘图识别命令、policy：
-- 借助plantuml + libs-plantuml 对上述事件进行绘图 --

------------------------------

在图中完备事件条件和命令条件，初步将命令和事件连线：
注：先完备命令，再完备事件(使用表示事物的唯一标识和业务规则)
事件的条件由自身或命令提供
此时将角色也带入
连线时可以补充“读模型”

保证：事件仅有一个命令发起，且发生的条件由自身或命令提供

------------------------------

识别聚合并连线：
聚合识别：以命令和事件的条件为识别基础
连线：命令 - 聚合 - 事件 （可以使用vscode查询 Command_  Event_  帮助快速定位）

注：构建聚合时，开始时为初步创建
进行连接时，会对聚合进行完善

连线的过程，是初步验证的过程，需要遵守“命令和事件不能有孤岛，命令与命令/事件与事件间不能有连接”
如果存在连接则需要重新进行完备分解

------------------------------

！！！完备聚合 ！！！
！！！识别读模型 ！！！

------------------------------

产出事件表和规则表：

------------------------------

业务需求的表达确认后，开始技术上的建模
技术实现： TDD 测试领域 -> 领域 -> 服务接口

如果需要其他系统或服务提供功能，需要将聚合替换为system或service

------------------------------

注：不建议跨步骤进行建模【秉持大家一起攻克问题域的一个方向】

------------------------------
